<?xml version="1.0" encoding="UTF-8"?>
<config>
  <abortOnConfigurationError>${solr.abortOnConfigurationError:true}</abortOnConfigurationError>
  <lib dir="../../contrib/extraction/lib"/>
  <lib dir="../../dist/" regex="apache-solr-cell-\d.*\.jar"/>
  <lib dir="../../dist/" regex="apache-solr-clustering-\d.*\.jar"/>
  <lib dir="../../contrib/clustering/lib/downloads/"/>
  <lib dir="../../contrib/clustering/lib/"/>
  <lib dir="/total/crap/dir/ignored"/>
  <dataDir>${solr.data.dir:./solr/data}</dataDir>
  <indexDefaults>
    <useCompoundFile>false</useCompoundFile>
    <mergeFactor>10</mergeFactor>
    <ramBufferSizeMB>32</ramBufferSizeMB>
    <!-- <maxMergeDocs>2147483647</maxMergeDocs> -->
    <maxFieldLength>10000</maxFieldLength>
    <writeLockTimeout>1000</writeLockTimeout>
    <commitLockTimeout>10000</commitLockTimeout>
    <lockType>native</lockType>
  </indexDefaults>
  <mainIndex>
    <useCompoundFile>false</useCompoundFile>
    <ramBufferSizeMB>32</ramBufferSizeMB>
    <mergeFactor>10</mergeFactor>
    <unlockOnStartup>false</unlockOnStartup>
    <reopenReaders>true</reopenReaders>
    <deletionPolicy class="solr.SolrDeletionPolicy">
      <str name="maxCommitsToKeep">1</str>
      <str name="maxOptimizedCommitsToKeep">0</str>
    </deletionPolicy>
    <infoStream file="INFOSTREAM.txt">false</infoStream>
  </mainIndex>
  <jmx/>
  <updateHandler class="solr.DirectUpdateHandler2">
  </updateHandler>
  <query>
    <maxBooleanClauses>1024</maxBooleanClauses>
    <filterCache class="solr.FastLRUCache" size="512" initialSize="512" autowarmCount="0"/>
    <queryResultCache class="solr.LRUCache" size="512" initialSize="512" autowarmCount="0"/>
    <documentCache class="solr.LRUCache" size="512" initialSize="512" autowarmCount="0"/>
    <enableLazyFieldLoading>true</enableLazyFieldLoading>
    <queryResultWindowSize>20</queryResultWindowSize>
    <queryResultMaxDocsCached>200</queryResultMaxDocsCached>
    <listener event="newSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
      </arr>
    </listener>
    <listener event="firstSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <lst>
          <str name="q">solr rocks</str>
          <str name="start">0</str>
          <str name="rows">10</str>
        </lst>
        <lst>
          <str name="q">static firstSearcher warming query from solrconfig.xml</str>
        </lst>
      </arr>
    </listener>
    <!-- If a search request comes in and there is no current registered searcher,
         then immediately register the still warming searcher and use it.  If
         "false" then all requests will block until the first searcher is done
         warming. -->
    <useColdSearcher>false</useColdSearcher>
    <!-- Maximum number of searchers that may be warming in the background
      concurrently.  An error is returned if this limit is exceeded. Recommend
      1-2 for read-only slaves, higher for masters w/o cache warming. -->
    <maxWarmingSearchers>2</maxWarmingSearchers>
  </query>
  <!-- 
    Let the dispatch filter handler /select?qt=XXX
    handleSelect=true will use consistent error handling for /select and /update
    handleSelect=false will use solr1.1 style error formatting
    -->
  <requestDispatcher handleSelect="true">
    <!--Make sure your system has some authentication before enabling remote streaming!  -->
    <requestParsers enableRemoteStreaming="true" multipartUploadLimitInKB="2048000"/>
    <!-- Set HTTP caching related parameters (for proxy caches and clients).
          
         To get the behaviour of Solr 1.2 (ie: no caching related headers)
         use the never304="true" option and do not specify a value for
         <cacheControl>
    -->
    <!-- <httpCaching never304="true"> -->
    <httpCaching lastModifiedFrom="openTime" etagSeed="Solr">
      <!-- lastModFrom="openTime" is the default, the Last-Modified value
            (and validation against If-Modified-Since requests) will all be
            relative to when the current Searcher was opened.
            You can change it to lastModFrom="dirLastMod" if you want the
            value to exactly corrispond to when the physical index was last
            modified.

            etagSeed="..." is an option you can change to force the ETag
            header (and validation against If-None-Match requests) to be
            differnet even if the index has not changed (ie: when making
            significant changes to your config file)

            lastModifiedFrom and etagSeed are both ignored if you use the
            never304="true" option.
       -->
      <!-- If you include a <cacheControl> directive, it will be used to
            generate a Cache-Control header, as well as an Expires header
            if the value contains "max-age="

            By default, no Cache-Control header is generated.

            You can use the <cacheControl> option even if you have set
            never304="true"
       -->
      <!-- <cacheControl>max-age=30, public</cacheControl> -->
    </httpCaching>
  </requestDispatcher>
  <!-- requestHandler plugins... incoming queries will be dispatched to the
     correct handler based on the path or the qt (query type) param.
     Names starting with a '/' are accessed with the a path equal to the 
     registered name.  Names without a leading '/' are accessed with:
      http://host/app/select?qt=name
     If no qt is defined, the requestHandler that declares default="true"
     will be used.
  -->
  <requestHandler name="standard" class="solr.SearchHandler" default="true">
    <!-- default values for query parameters -->
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <!--
       <int name="rows">10</int>
       <str name="fl">*</str>
       <str name="version">2.1</str>
        -->
    </lst>
  </requestHandler>
  <!-- Please refer to http://wiki.apache.org/solr/SolrReplication for details on configuring replication -->
  <!-- remove the <lst name="master"> section if this is just a slave -->
  <!-- remove  the <lst name="slave"> section if this is just a master -->
  <!--
<requestHandler name="/replication" class="solr.ReplicationHandler" >
    <lst name="master">
      <str name="replicateAfter">commit</str>
      <str name="replicateAfter">startup</str>
      <str name="confFiles">schema.xml,stopwords.txt</str>
    </lst>
    <lst name="slave">
      <str name="masterUrl">http://localhost:8983/solr/replication</str>
      <str name="pollInterval">00:00:60</str>
    </lst>
</requestHandler>-->
  <!-- DisMaxRequestHandler allows easy searching across multiple fields
       for simple user-entered phrases.  It's implementation is now
       just the standard SearchHandler with a default query type
       of "dismax". 
       see http://wiki.apache.org/solr/DisMaxRequestHandler
   -->
  <requestHandler name="dismax" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="defType">dismax</str>
      <str name="echoParams">explicit</str>
      <float name="tie">0.01</float>
      <str name="qf">
        text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0 manu^1.1 cat^1.4
     </str>
      <str name="pf">
        text^0.2 features^1.1 name^1.5 manu^1.4 manu_exact^1.9
     </str>
      <str name="bf">
        popularity^0.5 recip(price,1,1000,1000)^0.3
     </str>
      <str name="fl">
        id,name,price,score
     </str>
      <str name="mm">
        2&lt;-1 5&lt;-2 6&lt;90%
     </str>
      <int name="ps">100</int>
      <str name="q.alt">*:*</str>
      <!-- example highlighter config, enable per-query with hl=true -->
      <str name="hl.fl">text features name</str>
      <!-- for this field, we want no fragmenting, just highlighting -->
      <str name="f.name.hl.fragsize">0</str>
      <!-- instructs Solr to return the field itself if no query terms are
          found -->
      <str name="f.name.hl.alternateField">name</str>
      <str name="f.text.hl.fragmenter">regex</str>
      <!-- defined below -->
    </lst>
  </requestHandler>
  <!-- Note how you can register the same handler multiple times with
       different names (and different init parameters)
    -->
  <requestHandler name="partitioned" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="defType">dismax</str>
      <str name="echoParams">explicit</str>
      <str name="qf">text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0</str>
      <str name="mm">2&lt;-1 5&lt;-2 6&lt;90%</str>
      <!-- This is an example of using Date Math to specify a constantly
          moving date range in a config...
       -->
      <str name="bq">incubationdate_dt:[* TO NOW/DAY-1MONTH]^2.2</str>
    </lst>
    <!-- In addition to defaults, "appends" params can be specified
         to identify values which should be appended to the list of
         multi-val params from the query (or the existing "defaults").

         In this example, the param "fq=instock:true" will be appended to
         any query time fq params the user may specify, as a mechanism for
         partitioning the index, independent of any user selected filtering
         that may also be desired (perhaps as a result of faceted searching).

         NOTE: there is *absolutely* nothing a client can do to prevent these
         "appends" values from being used, so don't use this mechanism
         unless you are sure you always want it.
      -->
    <lst name="appends">
      <str name="fq">inStock:true</str>
    </lst>
    <!-- "invariants" are a way of letting the Solr maintainer lock down
         the options available to Solr clients.  Any params values
         specified here are used regardless of what values may be specified
         in either the query, the "defaults", or the "appends" params.

         In this example, the facet.field and facet.query params are fixed,
         limiting the facets clients can use.  Faceting is not turned on by
         default - but if the client does specify facet=true in the request,
         these are the only facets they will be able to see counts for;
         regardless of what other facet.field or facet.query params they
         may specify.

         NOTE: there is *absolutely* nothing a client can do to prevent these
         "invariants" values from being used, so don't use this mechanism
         unless you are sure you always want it.
      -->
    <lst name="invariants">
      <str name="facet.field">cat</str>
      <str name="facet.field">manu_exact</str>
      <str name="facet.query">price:[* TO 500]</str>
      <str name="facet.query">price:[500 TO *]</str>
    </lst>
  </requestHandler>
  <searchComponent name="spellcheck" class="solr.SpellCheckComponent">
    <str name="queryAnalyzerFieldType">textSpell</str>
    <lst name="spellchecker">
      <str name="name">default</str>
      <str name="field">name</str>
      <str name="spellcheckIndexDir">./spellchecker</str>
    </lst>
  </searchComponent>
  <requestHandler name="/spell" class="solr.SearchHandler" lazy="true">
    <lst name="defaults">
      <str name="spellcheck.onlyMorePopular">false</str>
      <str name="spellcheck.extendedResults">false</str>
      <str name="spellcheck.count">1</str>
    </lst>
    <arr name="last-components">
      <str>spellcheck</str>
    </arr>
  </requestHandler>
  <searchComponent name="tvComponent" class="org.apache.solr.handler.component.TermVectorComponent"/>
  <requestHandler name="tvrh" class="org.apache.solr.handler.component.SearchHandler">
    <lst name="defaults">
      <bool name="tv">true</bool>
    </lst>
    <arr name="last-components">
      <str>tvComponent</str>
    </arr>
  </requestHandler>
  <searchComponent name="clusteringComponent" enable="${solr.clustering.enabled:false}" class="org.apache.solr.handler.clustering.ClusteringComponent">
    <lst name="engine">
      <str name="name">default</str>
      <str name="carrot.algorithm">org.carrot2.clustering.lingo.LingoClusteringAlgorithm</str>
      <str name="LingoClusteringAlgorithm.desiredClusterCountBase">20</str>
    </lst>
    <lst name="engine">
      <str name="name">stc</str>
      <str name="carrot.algorithm">org.carrot2.clustering.stc.STCClusteringAlgorithm</str>
    </lst>
  </searchComponent>
  <requestHandler name="/clustering" enable="${solr.clustering.enabled:false}" class="solr.SearchHandler">
    <lst name="defaults">
      <bool name="clustering">true</bool>
      <str name="clustering.engine">default</str>
      <bool name="clustering.results">true</bool>
      <!-- The title field -->
      <str name="carrot.title">name</str>
      <str name="carrot.url">id</str>
      <!-- The field to cluster on -->
      <str name="carrot.snippet">features</str>
      <!-- produce summaries -->
      <bool name="carrot.produceSummary">true</bool>
      <!-- the maximum number of labels per cluster -->
      <!--<int name="carrot.numDescriptions">5</int>-->
      <!-- produce sub clusters -->
      <bool name="carrot.outputSubClusters">false</bool>
    </lst>
    <arr name="last-components">
      <str>clusteringComponent</str>
    </arr>
  </requestHandler>
  <!-- Solr Cell: http://wiki.apache.org/solr/ExtractingRequestHandler -->
  <requestHandler name="/update/extract" class="org.apache.solr.handler.extraction.ExtractingRequestHandler" startup="lazy">
    <lst name="defaults">
      <!-- All the main content goes into "text"... if you need to return
           the extracted text or do highlighting, use a stored field. -->
      <str name="fmap.content">text</str>
      <str name="lowernames">true</str>
      <str name="uprefix">ignored_</str>
      <!-- capture link hrefs but ignore div attributes -->
      <str name="captureAttr">true</str>
      <str name="fmap.a">links</str>
      <str name="fmap.div">ignored_</str>
    </lst>
  </requestHandler>
  <!-- A component to return terms and document frequency of those terms.
       This component does not yet support distributed search. -->
  <searchComponent name="termsComponent" class="org.apache.solr.handler.component.TermsComponent"/>
  <requestHandler name="/terms" class="org.apache.solr.handler.component.SearchHandler">
    <lst name="defaults">
      <bool name="terms">true</bool>
    </lst>
    <arr name="components">
      <str>termsComponent</str>
    </arr>
  </requestHandler>
  <!-- a search component that enables you to configure the top results for
       a given query regardless of the normal lucene scoring.-->
  <searchComponent name="elevator" class="solr.QueryElevationComponent">
    <!-- pick a fieldType to analyze queries -->
    <str name="queryFieldType">string</str>
    <str name="config-file">elevate.xml</str>
  </searchComponent>
  <!-- a request handler utilizing the elevator component -->
  <requestHandler name="/elevate" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
    </lst>
    <arr name="last-components">
      <str>elevator</str>
    </arr>
  </requestHandler>
  <!-- Update request handler.  

       Note: Since solr1.1 requestHandlers requires a valid content type header if posted in
       the body. For example, curl now requires: -H 'Content-type:text/xml; charset=utf-8'
       The response format differs from solr1.1 formatting and returns a standard error code.
       To enable solr1.1 behavior, remove the /update handler or change its path
    -->
  <requestHandler name="/update" class="solr.XmlUpdateRequestHandler"/>
  <requestHandler name="/update/javabin" class="solr.BinaryUpdateRequestHandler"/>
  <requestHandler name="/analysis/document" class="solr.DocumentAnalysisRequestHandler"/>
  <requestHandler name="/analysis/field" class="solr.FieldAnalysisRequestHandler"/>
  <requestHandler name="/update/csv" class="solr.CSVRequestHandler" startup="lazy"/>
  <requestHandler name="/admin/" class="org.apache.solr.handler.admin.AdminHandlers"/>
  <requestHandler name="/admin/ping" class="PingRequestHandler">
    <lst name="defaults">
      <str name="qt">standard</str>
      <str name="q">solrpingquery</str>
      <str name="echoParams">all</str>
    </lst>
  </requestHandler>
  <requestHandler name="/debug/dump" class="solr.DumpRequestHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <!-- for all params (including the default etc) use: 'all' -->
      <str name="echoHandler">true</str>
    </lst>
  </requestHandler>
  <highlighting>
    <fragmenter name="gap" class="org.apache.solr.highlight.GapFragmenter" default="true">
      <lst name="defaults">
        <int name="hl.fragsize">100</int>
      </lst>
    </fragmenter>
    <fragmenter name="regex" class="org.apache.solr.highlight.RegexFragmenter">
      <lst name="defaults">
        <int name="hl.fragsize">70</int>
        <float name="hl.regex.slop">0.5</float>
        <str name="hl.regex.pattern">[-\w ,/\n\"']{20,200}</str>
      </lst>
    </fragmenter>
    <formatter name="html" class="org.apache.solr.highlight.HtmlFormatter" default="true">
      <lst name="defaults">
        <str name="hl.simple.pre"><![CDATA[<em>]]></str>
        <str name="hl.simple.post"><![CDATA[</em>]]></str>
      </lst>
    </formatter>
  </highlighting>
  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter">
    <int name="xsltCacheLifetimeSeconds">5</int>
  </queryResponseWriter>
  <admin>
    <defaultQuery>solr</defaultQuery>
  </admin>
  <requestHandler class="solr.MoreLikeThisHandler" name="/mlt">
    <lst name="defaults">
      <str name="mlt.mintf">1</str>
      <str name="mlt.mindf">2</str>
    </lst>
  </requestHandler>
</config>
